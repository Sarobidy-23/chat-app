/* tslint:disable */
/* eslint-disable */
/**
 * chat-app
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ActualUser
 */
export interface ActualUser {
    /**
     * 
     * @type {number}
     * @memberof ActualUser
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActualUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActualUser
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActualUser
     */
    'googleId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActualUser
     */
    'bio'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActualUser
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActualUser
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActualUser
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActualUser
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActualUser
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface AddMemberRequest
 */
export interface AddMemberRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof AddMemberRequest
     */
    'members'?: Array<number>;
}
/**
 * 
 * @export
 * @interface AllChannelResponse
 */
export interface AllChannelResponse {
    /**
     * 
     * @type {RequestStatus}
     * @memberof AllChannelResponse
     */
    'status'?: RequestStatus;
    /**
     * 
     * @type {Channel}
     * @memberof AllChannelResponse
     */
    'channels'?: Channel;
}
/**
 * 
 * @export
 * @interface AllMessageResponse
 */
export interface AllMessageResponse {
    /**
     * 
     * @type {RequestStatus}
     * @memberof AllMessageResponse
     */
    'status'?: RequestStatus;
    /**
     * 
     * @type {Array<AllMessageResponseMessagesInner>}
     * @memberof AllMessageResponse
     */
    'messages'?: Array<AllMessageResponseMessagesInner>;
}
/**
 * 
 * @export
 * @interface AllMessageResponseMessagesInner
 */
export interface AllMessageResponseMessagesInner {
    /**
     * 
     * @type {number}
     * @memberof AllMessageResponseMessagesInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AllMessageResponseMessagesInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AllMessageResponseMessagesInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {SenderMessage}
     * @memberof AllMessageResponseMessagesInner
     */
    'sender'?: SenderMessage;
    /**
     * 
     * @type {number}
     * @memberof AllMessageResponseMessagesInner
     */
    'senderId'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllMessageResponseMessagesInner
     */
    'channelId'?: number;
    /**
     * 
     * @type {number}
     * @memberof AllMessageResponseMessagesInner
     */
    'recipientId'?: number;
    /**
     * 
     * @type {string}
     * @memberof AllMessageResponseMessagesInner
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface AllMessageResponseMessagesInnerAllOf
 */
export interface AllMessageResponseMessagesInnerAllOf {
    /**
     * 
     * @type {number}
     * @memberof AllMessageResponseMessagesInnerAllOf
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AllMessageResponseMessagesInnerAllOf
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AllMessageResponseMessagesInnerAllOf
     */
    'createdAt'?: string;
    /**
     * 
     * @type {SenderMessage}
     * @memberof AllMessageResponseMessagesInnerAllOf
     */
    'sender'?: SenderMessage;
}
/**
 * 
 * @export
 * @interface AllUserResponse
 */
export interface AllUserResponse {
    /**
     * 
     * @type {RequestStatus}
     * @memberof AllUserResponse
     */
    'status'?: RequestStatus;
    /**
     * 
     * @type {Array<User>}
     * @memberof AllUserResponse
     */
    'users'?: Array<User>;
}
/**
 * 
 * @export
 * @interface Channel
 */
export interface Channel {
    /**
     * 
     * @type {string}
     * @memberof Channel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Channel
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Channel
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof Channel
     */
    'ownerId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Channel
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Channel
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface CreateChannel
 */
export interface CreateChannel {
    /**
     * 
     * @type {string}
     * @memberof CreateChannel
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateChannel
     */
    'type'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateChannel
     */
    'members'?: Array<number>;
}
/**
 * 
 * @export
 * @interface CreateMessage
 */
export interface CreateMessage {
    /**
     * 
     * @type {number}
     * @memberof CreateMessage
     */
    'senderId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateMessage
     */
    'channelId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateMessage
     */
    'recipientId'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateMessage
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface CreateUser
 */
export interface CreateUser {
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUser
     */
    'bio'?: string;
}
/**
 * 
 * @export
 * @interface LoginInfo
 */
export interface LoginInfo {
    /**
     * 
     * @type {string}
     * @memberof LoginInfo
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginInfo
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface MemberAdded
 */
export interface MemberAdded {
    /**
     * 
     * @type {RequestStatus}
     * @memberof MemberAdded
     */
    'status'?: RequestStatus;
    /**
     * 
     * @type {Array<number>}
     * @memberof MemberAdded
     */
    'userAdded'?: Array<number>;
}
/**
 * 
 * @export
 * @interface OneChannelResponse
 */
export interface OneChannelResponse {
    /**
     * 
     * @type {RequestStatus}
     * @memberof OneChannelResponse
     */
    'status'?: RequestStatus;
    /**
     * 
     * @type {Channel}
     * @memberof OneChannelResponse
     */
    'channel'?: Channel;
}
/**
 * 
 * @export
 * @interface OneMessageResponse
 */
export interface OneMessageResponse {
    /**
     * 
     * @type {RequestStatus}
     * @memberof OneMessageResponse
     */
    'status'?: RequestStatus;
    /**
     * 
     * @type {OneMessageResponseMessage}
     * @memberof OneMessageResponse
     */
    'message'?: OneMessageResponseMessage;
}
/**
 * 
 * @export
 * @interface OneMessageResponseMessage
 */
export interface OneMessageResponseMessage {
    /**
     * 
     * @type {number}
     * @memberof OneMessageResponseMessage
     */
    'senderId'?: number;
    /**
     * 
     * @type {number}
     * @memberof OneMessageResponseMessage
     */
    'channelId'?: number;
    /**
     * 
     * @type {number}
     * @memberof OneMessageResponseMessage
     */
    'recipientId'?: number;
    /**
     * 
     * @type {string}
     * @memberof OneMessageResponseMessage
     */
    'content'?: string;
    /**
     * 
     * @type {number}
     * @memberof OneMessageResponseMessage
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OneMessageResponseMessage
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OneMessageResponseMessage
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface OneMessageResponseMessageAllOf
 */
export interface OneMessageResponseMessageAllOf {
    /**
     * 
     * @type {number}
     * @memberof OneMessageResponseMessageAllOf
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OneMessageResponseMessageAllOf
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OneMessageResponseMessageAllOf
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface OneUserResponse
 */
export interface OneUserResponse {
    /**
     * 
     * @type {RequestStatus}
     * @memberof OneUserResponse
     */
    'status'?: RequestStatus;
    /**
     * 
     * @type {ActualUser}
     * @memberof OneUserResponse
     */
    'user'?: ActualUser;
}
/**
 * 
 * @export
 * @interface RequestStatus
 */
export interface RequestStatus {
    /**
     * 
     * @type {boolean}
     * @memberof RequestStatus
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface SenderMessage
 */
export interface SenderMessage {
    /**
     * 
     * @type {number}
     * @memberof SenderMessage
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SenderMessage
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SenderMessage
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUser
 */
export interface UpdateUser {
    /**
     * 
     * @type {string}
     * @memberof UpdateUser
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUser
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUser
     */
    'oldPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUser
     */
    'bio'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'bio'?: string;
}

/**
 * ChannelApi - axios parameter creator
 * @export
 */
export const ChannelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} channelId 
         * @param {AddMemberRequest} addMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMember: async (channelId: number, addMemberRequest: AddMemberRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('addMember', 'channelId', channelId)
            // verify required parameter 'addMemberRequest' is not null or undefined
            assertParamExists('addMember', 'addMemberRequest', addMemberRequest)
            const localVarPath = `/channels/{channelId}/members`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateChannel} createChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannel: async (createChannel: CreateChannel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createChannel' is not null or undefined
            assertParamExists('createChannel', 'createChannel', createChannel)
            const localVarPath = `/channel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createChannel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOne: async (channelId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('getOne', 'channelId', channelId)
            const localVarPath = `/channel/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelApi - functional programming interface
 * @export
 */
export const ChannelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChannelApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} channelId 
         * @param {AddMemberRequest} addMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMember(channelId: number, addMemberRequest: AddMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberAdded>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMember(channelId, addMemberRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateChannel} createChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChannel(createChannel: CreateChannel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OneChannelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChannel(createChannel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AllChannelResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOne(channelId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OneChannelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOne(channelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChannelApi - factory interface
 * @export
 */
export const ChannelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChannelApiFp(configuration)
    return {
        /**
         * 
         * @param {number} channelId 
         * @param {AddMemberRequest} addMemberRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMember(channelId: number, addMemberRequest: AddMemberRequest, options?: any): AxiosPromise<MemberAdded> {
            return localVarFp.addMember(channelId, addMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateChannel} createChannel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChannel(createChannel: CreateChannel, options?: any): AxiosPromise<OneChannelResponse> {
            return localVarFp.createChannel(createChannel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll(options?: any): AxiosPromise<Array<AllChannelResponse>> {
            return localVarFp.getAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOne(channelId: number, options?: any): AxiosPromise<OneChannelResponse> {
            return localVarFp.getOne(channelId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChannelApi - object-oriented interface
 * @export
 * @class ChannelApi
 * @extends {BaseAPI}
 */
export class ChannelApi extends BaseAPI {
    /**
     * 
     * @param {number} channelId 
     * @param {AddMemberRequest} addMemberRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public addMember(channelId: number, addMemberRequest: AddMemberRequest, options?: AxiosRequestConfig) {
        return ChannelApiFp(this.configuration).addMember(channelId, addMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateChannel} createChannel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public createChannel(createChannel: CreateChannel, options?: AxiosRequestConfig) {
        return ChannelApiFp(this.configuration).createChannel(createChannel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public getAll(options?: AxiosRequestConfig) {
        return ChannelApiFp(this.configuration).getAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} channelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public getOne(channelId: number, options?: AxiosRequestConfig) {
        return ChannelApiFp(this.configuration).getOne(channelId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MessageApi - axios parameter creator
 * @export
 */
export const MessageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateMessage} createMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessage: async (createMessage: CreateMessage, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMessage' is not null or undefined
            assertParamExists('createMessage', 'createMessage', createMessage)
            const localVarPath = `/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMessage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByChannelId: async (channelId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('getByChannelId', 'channelId', channelId)
            const localVarPath = `/messages/channel/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUserId: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getByUserId', 'userId', userId)
            const localVarPath = `/messages/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessageApi - functional programming interface
 * @export
 */
export const MessageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateMessage} createMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMessage(createMessage: CreateMessage, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OneMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMessage(createMessage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByChannelId(channelId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AllMessageResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByChannelId(channelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByUserId(userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AllMessageResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByUserId(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MessageApi - factory interface
 * @export
 */
export const MessageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessageApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateMessage} createMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessage(createMessage: CreateMessage, options?: any): AxiosPromise<OneMessageResponse> {
            return localVarFp.createMessage(createMessage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByChannelId(channelId: number, options?: any): AxiosPromise<Array<AllMessageResponse>> {
            return localVarFp.getByChannelId(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUserId(userId: number, options?: any): AxiosPromise<Array<AllMessageResponse>> {
            return localVarFp.getByUserId(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessageApi - object-oriented interface
 * @export
 * @class MessageApi
 * @extends {BaseAPI}
 */
export class MessageApi extends BaseAPI {
    /**
     * 
     * @param {CreateMessage} createMessage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public createMessage(createMessage: CreateMessage, options?: AxiosRequestConfig) {
        return MessageApiFp(this.configuration).createMessage(createMessage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} channelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public getByChannelId(channelId: number, options?: AxiosRequestConfig) {
        return MessageApiFp(this.configuration).getByChannelId(channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public getByUserId(userId: number, options?: AxiosRequestConfig) {
        return MessageApiFp(this.configuration).getByUserId(userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrent: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginInfo} loginInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginInfo: LoginInfo, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginInfo' is not null or undefined
            assertParamExists('login', 'loginInfo', loginInfo)
            const localVarPath = `/users/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateUser} createUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup: async (createUser: CreateUser, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUser' is not null or undefined
            assertParamExists('signup', 'createUser', createUser)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateUser} updateUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (updateUser: UpdateUser, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUser' is not null or undefined
            assertParamExists('update', 'updateUser', updateUser)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrent(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OneUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {LoginInfo} loginInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginInfo: LoginInfo, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OneUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginInfo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateUser} createUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signup(createUser: CreateUser, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OneUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signup(createUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateUser} updateUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(updateUser: UpdateUser, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OneUserResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(updateUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geAll(options?: any): AxiosPromise<AllUserResponse> {
            return localVarFp.geAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrent(options?: any): AxiosPromise<OneUserResponse> {
            return localVarFp.getCurrent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginInfo} loginInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginInfo: LoginInfo, options?: any): AxiosPromise<OneUserResponse> {
            return localVarFp.login(loginInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateUser} createUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(createUser: CreateUser, options?: any): AxiosPromise<OneUserResponse> {
            return localVarFp.signup(createUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateUser} updateUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(updateUser: UpdateUser, options?: any): AxiosPromise<Array<OneUserResponse>> {
            return localVarFp.update(updateUser, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public geAll(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).geAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getCurrent(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getCurrent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginInfo} loginInfo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public login(loginInfo: LoginInfo, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).login(loginInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateUser} createUser 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public signup(createUser: CreateUser, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).signup(createUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateUser} updateUser 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public update(updateUser: UpdateUser, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).update(updateUser, options).then((request) => request(this.axios, this.basePath));
    }
}


